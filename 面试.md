#### 简述堆排序

将排序数组看作一个树状数组，建立一个二叉树堆。通过对这种数据结构进行每一个元素的插入，完成排序工作。排序算法不稳定。

#### 浏览器输入url过程

进行DNS解析操作，根据DNS解析获得的结果查到服务器ip地址，通过ip寻址和arp，找到服务器，并利用三次握手建立TCP连接浏览器生成HTTP报文，发送HTTP请求，等待服务器响应处理请求，并返回给浏览器HTTP是否开启长连接，进行TCP挥手过程，浏览器根据收到的静态请求资源进行页面渲染

#### https握手过程

https连接过程

浏览器将支持的加密算法信息发给服务器，服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器，客户端（SSL/TLS）解析证书验证证书合法性，生成对称加密的密钥。我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。服务器将加密后的密文发送给客户端 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。

![img](https://images2017.cnblogs.com/blog/1260476/201711/1260476-20171116160813812-635766483.png)

#### 为什么要有time-wait

MSL即报文最大生存时间。

设置2MSL(time-wait状态)可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。

#### MySql日志

redo log: 存储引擎级别的log（InnoDB有，MyISAM没有），该log关注于事务的恢复.在重启mysql服务的时候，根据redo log进行重做，从而使事务有持久性。

undo log：是存储引擎级别的log（InnoDB有，MyISAM没有）保证数据的原子性，该log保存了事务发生之前的数据的一个版本，可以用于回滚，是MVCC的重要实现方法之一。

bin log：数据库级别的log，关注恢复数据库的数据。

#### AQS原理及作用

AQS（AbstractQuenedSynchronizer）抽象的队列式同步器。AQS是将每一条请求共享资源的线程封装成一个锁队列的一个结点（Node），来实现锁的分配。AQS是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码（指的是一个访问共用资源的程序片段），释放资源时会通知同步队列中的等待线程。



子类通过继承同步器并实现它的抽象方法getState、setState 和 compareAndSetState对同步状态进行更改。

#### Executors有了解吗

Executor框架目的是将任务提交和任务如何运行分离开来的机制。用户不再需要从代码层考虑设计任务的提交运行，只需要调用Executor框架实现类的Execute方法就可以提交任务。产生线程池的函数ThreadPoolExecutor也是Executor的具体实现类。**还有关键的一点**：有助于避免this逃逸问题

Executor框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable等。

**Executor**：一个接口，其定义了一个接收Runnable对象的方法executor，其方法签名为executor(Runnable command),该方法接收一个Runable实例，它用来执行一个任务，任务即一个实现了Runnable接口的类，一般来说，Runnable任务开辟在新线程中的使用方法为：new Thread(new RunnableTask())).start()，但在Executor中，可以使用Executor而不用显示地创建线程：executor.execute(new RunnableTask()); // 异步执行

**ExecutorService**：是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法，返回 Future 对象，以及可跟踪一个或多个异步任务执行状况返回Future的方法；可以调用ExecutorService的shutdown（）方法来平滑地关闭 ExecutorService，调用该方法后，将导致ExecutorService停止接受任何新的任务且等待已经提交的任务执行完成(已经提交的任务会分两类：一类是已经在执行的，另一类是还没有开始执行的)，当所有已经提交的任务执行完毕后将会关闭ExecutorService。因此我们一般用该接口来实现和管理多线程。

**Executors**类： 主要用于提供线程池相关的操作，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。

#### 简述TCP三次握手

第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq=x，并将该数据包发送给服务端，客户端 进入syn_sent状态，等待服务端确认。

第二次握手:服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和 ACK都置为1，ack=x+1,随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。

第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输数据了

#### TCP四次挥手

第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入finwait1状态。

第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。

第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。

第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。

#### TCP,UDP的区别

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等。

TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。

#### 计算机插上电源操作系统做了什么

1. 加电––––打开电源开关，给主板和内部风扇供电。
2. 启动引导程序––––CPU开始执行存储在ROM BIOS中的指令。 
3. 开机自检––––计算机对系统的主要部件进行诊断测试。 
4. 加载操作系统––––计算机将操作系统文件从磁盘读到内存中。 
5. 检查配置文件，定制操作系统的运行环境––––读取配置文件，根据用户的设置对操作系统进行定制。 
6. 准备读取命令和数据––––计算机等待用户输入命令和数据。 

#### TCP/IP协议的体系结构分为哪几层？每层的功能？

应用层：是直接为应用进程提供服务的。对不同种类的应用程序它们会根据自己的需要来使用应用层的不同协议；

运输层：主要功能是定义端口，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性。

网络层：在TCP/IP协议中网络层可以进行网络连接的建立和终止以及IP地址的寻找等功能。网络层的主要功能是定义网络地址、区分网段、子网内MAC寻址、对于不同子网的数据包进行路由。

网络接口层：由于网络接口层兼并了物理层和数据链路层，所以网络接口层既是传输数据的物理媒介，也可以为网络层提供一条准确无误的线路。

#### HTTP2.0与1.0区别

提出多路复用。多路复用前，文件时串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。

引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。

#### 乐观锁与悲观锁

乐观锁：对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，只有到数据提交的时候才通过一种机制来验证数据是否存在冲突。

悲观锁：对于数据冲突保持一种悲观态度，在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。



MySQL具体如何实现乐观锁

可以通过新加数据版本字段，完成乐观锁。

MVCC也借鉴了这个思想。

MVCC为多版本并发控制，即同一条记录在系统中存在多个版本。其存在目的是在保证数据一致性的前提下提供一种高并发的访问性能。对数据读写在不加读写锁的情况下实现互不干扰,从而实现数据库的隔离性,在事务隔离级别为读提交和可重复读中使用到。）

#### 简述MySQL复合索引

联合索引是指对表上的多个列的关键词进行索引。

对于联合索引的查询，如果精确匹配联合索引的左边连续一列或者多列，则mysql会一直向右匹配直到遇到范围查询（>,<,between,like）就停止匹配。Mysql会对第一个索引字段数据进行排序，在第一个字段基础上，再对第二个字段排序。

#### 简述explain //TODO

#### 输入URL发生了什么

进行DNS解析操作，根据DNS解析的结果查到服务器IP地址

通过ip寻址和arp，找到服务器，并利用三次握手建立TCP连接

浏览器生成HTTP报文，发送HTTP请求，等待服务器响应

服务器处理请求，并返回给浏览器

根据HTTP是否开启长连接，进行TCP的挥手过程

浏览器根据收到的静态资源进行页面渲染

#### 线程池核心参数

corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。

maximumPoolSize：线程池能够容纳同时执行的线程最大数。

keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。

workQueue：工作队列。

threadFactory：线程工厂，用来生产一组相同任务的线程。

handler：拒绝策略。

#### 线程同步的方法

1. 同步方法（synchronized关键字修饰的方法）。**注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。**
2. 同步代码块，即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步
3. wait与notify
4. 使用特殊域变量(volatile)实现线程同步
5. 使用重入锁实现线程同步
6. 使用局部变量实现线程同步（ThreadLocal）
7. 使用阻塞队列实现线程同步
8. 使用原子变量实现线程同步,在java的**util.concurrent.atomic包中提供了创建了原子类型变量的工具类**，使用该类可以简化线程同步。其中**AtomicInteger** 表可以用原子方式更新int的值。

#### 怎么获取线程的返回值

1. 主线程等待
2. Join方法等待
3. 实现Callable接口（使用FutureTask或者线程池）

#### 进程和线程的区别

一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。

进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）

进程是资源分配的最小单位，线程是CPU调度的最小单位。

通信：由于同一进程中的多个线程具有相同的地址空间，使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步方法，以保证数据的一致性）。

进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。

进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。

进程适应于多核、多机分布；线程适用于多核。

#### 进程和线程的通信方式

进程间通信主要包括管道、系统IPC（包括管道、消息队列、信号量、信号、共享内存等）、以及套接字socket。线程通信方式：volatile 关键词修饰变量，保证所有线程对变量访问的可见性。synchronized关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。wait/notify方法 IO通信

#### Linux命令

top命令 查询cpu状态

tail 或者cat命令  查询日志

SCP命令  服务器传文件

#### 红黑树

红黑树本身是有2-3树发展而来，红黑树是保持黑平衡的二叉树，其查找会比AVL树慢一点，添加和删除元素会比AVL树快一点。增删改查统计性能上讲，红黑树更优。红黑树主要特征是在每个节点上增加一个属性表示节点颜色，可以红色或黑色。红黑树和 AVL 树类似，都是在进行插入和删除时通过旋转保持自身平衡，从而获得较高的查找性能。红黑树保证从根节点到叶尾的最长路径不超过最短路径的 2 倍，所以最差时间复杂度是 O(logn)。红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除之后的自平衡调整。

#### ArrayList和LinkedList的区别

ArrayList基于存储元素的Object[] array来实现的，它们会在内存中开辟一块连续的空间来存储，支持下标、索引访问。但在涉及插入元素时可能需要移动容器中的元素，插入效率较低。当存储元素超过容器的初始化容量大小，ArrayList与Vector均会进行扩容。

LinkedList采用双向列表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，但在插入元素的时候不需要对数据进行移动，插入效率较高。

#### ArrayList扩容机制

如果之前ArrayList，添加新元素后的存储空间不够，ArrayList会采用扩容机制，即在内存中申请原空间的1.5倍空间，并把原数组的值复制到新数组上，以此完成扩容。

#### 垃圾回收算法

标记清除算法：先标记需清除的对象，之后统一回收。这种方法效率不高，会产生大量不连续的碎片。

标记整理算法：先标记存活对象，然后让所有存活对象向一端移动，之后清理端边界以外的内存

标记复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。

#### 垃圾收集器 //TODO

串行收集器:Serial,Serial Old 并行收集器:Parallel Scavenge,Parallel Old 并发收集器：CMS,G1

#### volatile关键字原理

禁止指令重排序优化。使用 volatile 变量进行写操作，汇编指令带有 lock 前缀，相当于一个内存屏障，编译器不会将后面的指令重排到内存屏障之前。

#### threadlocal底层原理

ThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。

set 给ThreadLocalMap设置值。get 获取ThreadLocalMap。remove 删除ThreadLocalMap类型的对象。

#### B+树结构特点 以及优点

B+树也是是一种自平衡的多叉树。其基本定义与B树相同，不同点在于数据只出现在叶子节点，所有叶子节点增加了一个链指针，方便进行范围查询。

B+树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，访问叶子节点上关联的数据也具有更好的缓存命中率。并且数据顺序排列并且相连，所以便于区间查找和搜索。

#### 主键索引和辅助索引具体是什么

主键按每张表的主键构建一棵B+树，数据库中的每个搜索键值都有一个索引记录，每个数据页通过双向链表连接。表数据访问更快，但表更新代价高。

辅助索引是非聚集索引，叶子节点不包含记录的全部数据，包含了一个书签用来告诉InnoDB哪里可以找到与索引相对应的行数据。

通过辅助索引查询，先通过书签查到聚集索引，再根据聚集索引查对应的值，需要两次，也称为回表查询。

#### Hashmap的底层结构

JDK8 之前底层实现是数组 + 链表，JDK8 改为数组 + 链表/红黑树。主要成员变量包括存储数据的 table 数组、元素数量 size、加载因子 loadFactor。HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的 hash 值一样，就会发生哈希冲突，被放到同一个链表上。

table 数组记录 HashMap 的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链表，Node/Entry 节点包含四个成员变量：key、value、next 指针和 hash 值。在JDK8后链表超过8会转化为红黑树。

若当前数据/总数据容量>负载因子，Hashmap将执行扩容操作。默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1<< 30 、默认加载因子为 0.75。

#### 聚集索引和非聚集索引

聚集索引按每张表的主键构建一棵B+树，数据库中的每个搜索键值都有一个索引记录，每个数据页通过双向链表连接。表数据访问更快，但表更新代价高。

非聚簇索引不会为每个搜索关键字创建索引记录。搜索过程需要，我们首先按索引记录进行操作，并按顺序搜索，直到找到所需的数据为止。

#### 操作系统进程间通信性能最高的方式是哪种 为什么

共享内存。因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。

#### 进程间遇到同时读取一个数据 会遇到什么问题 怎么解决

如果同时读不会出现什么问题，但如果有一个进程涉及写操作，就会产生读写冲突，需要通过互斥锁和信号量等解决。

#### 简述协程

协程，即用户态线程。我们知道，在Linux下，线程有PCB，然后可以占用时间片去调度，但是在用户态线程中，该线程的执行不由内核做调度，由用户自己实现

可以这么理解，在用户进程A中，再实现了个调度器，调度用户线程，这些线程不像之前的线程，内核是感知不到的，它们只能感知到A的存在，用户态线程之间时间片只能争取内核分给进程A的时间片。

#### DOM是什么

DOM实际上是以面向对象方式描述的文档模型。DOM定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。可以把DOM认为是页面上数据和结构的一个树形表示，不过页面当然可能并不是以这种树的方式具体实现。